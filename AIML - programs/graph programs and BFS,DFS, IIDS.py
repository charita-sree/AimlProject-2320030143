# -*- coding: utf-8 -*-
"""graph plotting.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kkszmS9AUEB3cxbUN8glAxJTtjIcyCSc
"""

from matplotlib import pyplot as plt

 #Plotting to our canvas

plt.plot([1,2,3],[4,5,1])

 #Showing what we plotted

plt.show()

Graph_nodes = {
    'A': [('B', 6), ('F', 3)],
    'B': [('C', 3), ('D', 2)],
    'C': [('D', 1), ('E', 5)],
    'D': [('C', 1), ('E', 8)],
    'E': [('I', 5), ('J', 5)],
    'F': [('G', 1), ('H', 7)],
    'G': [('I', 3)],
    'H': [('I', 2)],
    'I': [('E', 5), ('J', 3)],

}


def get_neighbors(v):
    if v in Graph_nodes:
        return Graph_nodes[v]
    else:
        return None


def h(n):
    H_dist = {
        'A': 10,
        'B': 8,
        'C': 5,
        'D': 7,
        'E': 3,
        'F': 6,
        'G': 5,
        'H': 3,
        'I': 1,
        'J': 0
    }
    return H_dist[n]


def aStarAlgo(start_node, stop_node):
    open_set = set(start_node)
    closed_set = set()
    g = {}
    parents = {}
    g[start_node] = 0
    parents[start_node] = start_node

    while len(open_set) > 0:
        n = None

        for v in open_set:
            if n == None or g[v] + h(v) < g[n] + h(n):
                n = v

        if n == stop_node or Graph_nodes[n] == None:
            pass
        else:
            for (m, weight) in get_neighbors(n):
                if m not in open_set and m not in closed_set:
                    open_set.add(m)
                    parents[m] = n
                    g[m] = g[n] + weight

                else:
                    if g[m] > g[n] + weight:
                        g[m] = g[n] + weight
                        parents[m] = n
                        if m in closed_set:
                            closed_set.remove(m)
                            open_set.add(m)

        if n == None:
            print('Path does not exist!')
            return None
        if n == stop_node:
            path = []

            while parents[n] != n:
                path.append(n)
                n = parents[n]

            path.append(start_node)

            path.reverse()

            print('Path found: {}'.format(path))
            return path
        open_set.remove(n)
        closed_set.add(n)

    print('Path does not exist!')
    return None


aStarAlgo('A', 'J')

graph = {
  '5' : ['3','7'],
  '3' : ['2', '4'],
  '7' : ['8'],
  '2' : [],
  '4' : ['8'],
  '8' : []
}

visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0)
    print (m, end = " ")

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)

# Driver Code
print("Following is the Breadth-First Search")
bfs(visited, graph, '5')    # function calling

# Using a Python dictionary to act as an adjacency list
graph = {
  '5' : ['3','7'],
  '3' : ['2', '4'],
  '7' : ['8'],
  '2' : [],
  '4' : ['8'],
  '8' : []
}

visited = set() # Set to keep track of visited nodes of graph.

def dfs(visited, graph, node):  #function for dfs
    if node not in visited:
        print (node)
        visited.add(node)
        for neighbour in graph[node]:
            dfs(visited, graph, neighbour)

# Driver Code
print("Following is the Depth-First Search")
dfs(visited, graph, '5')

def dfs_limited(graph, node, target, depth, visited=None):
    if visited is None:
        visited = set()

    visited.add(node)

    # If target is found, return True
    if node == target:
        return True

    # If depth limit reached, return False
    if depth <= 0:
        return False

    # Recur for all adjacent vertices
    for neighbor in graph[node]:
        if neighbor not in visited:
            if dfs_limited(graph, neighbor, target, depth - 1, visited):
                return True

    return False

def iterative_deepening_search(graph, start, target, max_depth):
    for depth in range(max_depth + 1):
        print(f"Searching at depth: {depth}")
        visited = set()
        if dfs_limited(graph, start, target, depth, visited):
            print(f"Target {target} found at depth {depth}")
            return True
    print(f"Target {target} not found within depth {max_depth}")
    return False

# Example graph represented as an adjacency list
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}

# Start IDS from node 'A' looking for node 'F' with max depth of 3
print("Iterative Deepening Search starting from node 'A':")
iterative_deepening_search(graph, 'A', 'F', 3)

import random

def create_environment(size):
    return {
        'size': size,
        'agent_position': [0, 0]
    }

def is_valid_move(environment, position):
    size = environment['size']
    return 0 <= position[0] < size and 0 <= position[1] < size

def perceive(environment):
    return environment['agent_position']

def act(environment):
    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # Up, Down, Left, Right
    random_move = random.choice(moves)
    new_position = [
        environment['agent_position'][0] + random_move[0],
        environment['agent_position'][1] + random_move[1]
    ]

    if is_valid_move(environment, new_position):
        environment['agent_position'] = new_position
        return f"Moved to {environment['agent_position']}"
    else:
        return "Cannot move, stayed in place"

def main():
    env_size = 5
    num_steps = 10

    environment = create_environment(env_size)

    print(f"Starting position: {perceive(environment)}")

    for step in range(num_steps):
        print(f"Step {step + 1}: {act(environment)}")

if __name__ == "__main__":
    main()

import networkx as nx
import matplotlib.pyplot as plt
from queue import PriorityQueue

def best_first_search(G, start, goal):
    frontier = PriorityQueue()
    frontier.put((0, start, [start]))
    while not frontier.empty():
        _, node, path = frontier.get()
        if node == goal:
            return path
        for neighbor in G[node]:
            if neighbor not in path:
                new_path = path + [neighbor]
                priority = abs(ord(neighbor) - ord(goal))
                frontier.put((priority, neighbor, new_path))
    return None

G = nx.Graph([('A', 'B'), ('A', 'C'), ('B', 'D'), ('B', 'E'), ('C', 'F'),
              ('C', 'G'), ('D', 'H'), ('E', 'I'), ('F', 'J'), ('G', 'K'),
              ('H', 'L'), ('I', 'L'), ('J', 'L'), ('K', 'L')])

path = best_first_search(G, 'A', 'L')
print("Path:", ' -> '.join(path) if path else "No path found")

pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=500)
if path:
    nx.draw_networkx_edges(G, pos, edgelist=list(zip(path, path[1:])), edge_color='r', width=2)
    nx.draw_networkx_nodes(G, pos, nodelist=[path[0], path[-1]], node_color=['g', 'r'], node_size=600)
plt.show()

x = [5,2,7,5]
y = [2,16,4,2]
plt.plot(x,y)
plt.title('Info')
plt.ylabel('Y axis')
plt.xlabel('X axis')
plt.show()

import matplotlib.pyplot as plt

x = [1, 2, 3, 4, 5]
y = [2, 3, 5, 7, 11]

font_0 = {'family': 'serif', 'style': 'italic'}

plt.plot(x, y, '--*', color='#70a431')
plt.xlabel('The x label')
plt.ylabel('The y label')
plt.title('A matplotlib plot', fontdict=font_0, fontsize=15, loc='left')

plt.show()